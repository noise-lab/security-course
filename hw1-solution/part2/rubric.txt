Total points:   80

RSAKeyPair     - 10 points 
RSAKey         - 53 points
KeyExchange    - 17 points

If a point deduction says "P.o.P." this means you should post on 
the staff Piazza  so we can discuss. Remember to mark your post private.

Special note: For this assignment, please deduct only a total of 4 points
total for static variable errors! In other words, if their entire pipeline
is broken because of static variables, and is otherwise totally functional,
you should give them an overall score of 76/80.

A student can score at worst a 0 on any particular program. This list
will certainly grow, so keep an eye on it as you go.

General errors:
======================================================================
 * Does not compile
   [ -8 and ask student to resubmit ]

 * API check fails.
   [ Case by case basis - post on Piazza ]
 
 * Uses disallowed crypto libraries
   [ Case by case basis - post on Piazza ]

 * Has checkstyle errors that are not justified
   [ -2 - Error for importing ByteBuffer should be ignored ]

 * Has findbug errors that are not justified
   [ -2 ]
 
* Has print statements that must be commented out to run
   [ -2 ]

* Convoluted style / design (max: -2 for entire assignment)
   [ -2 ]

RSAKey (53 points max) [additive rubric]
=====================================================================

Core OAEP algorithm in .encrypt (15 points)
 * [ +6 ] Correct scheme for generating 128 random bits to seed G

          Only give full credit for their G seeding scheme if they
          can correctly handle MULTIPLE calls to encrypt/decrypt
          etc. If they get exceptions (from multiple
          calls), they should get 0 of these points.

 * [ +2 ] Properly appends 128 zeros and 128 random bits
 * [ +2 ] G correctly seeded 
 * [ +2 ] Bits properly generated by G and XORed against input
 * [ +1 ] H properly seeded
 * [ +1 ] H evaluated on correct input
 * [ +1 ] Output of H properly XORred against random bits

Core OAEP algorithm in .decrypt (10 points) [additive]
 * [ +1 ] H properly seeded
 * [ +1 ] H evaluated on correct input
 * [ +2 ] Output of H properly XORred against right 128 bits of input
 * [ +2 ] Random bits properly used to reseed G
 * [ +2 ] Bits properly generated by G and XORed against input
 * [ +2 ] Recovered zeroes are checked to ensure mesage was correct

maxPlaintextLength (4 points)
 * [ +4 ] maxPlaintextLength is reasonable
   [ +2 ] maxPlaintextLength is flagrantly wasteful
   [ +0 ] maxPlaintextLength is useless

.encrypt() -- not counting core OAEP algorithm (6 points)
 * [ +2 ] input is correctly padded given value of maxPlaintextLength
          don't count off here for errors due to bad maxPlaintextLength
 * [ +2 ] proper steps taken to ensure modPow does not destroy information
          (e.g. marker bit)
 * [ +1 ] conversion to positive big integer
 * [ +1 ] modpow

.decrypt() -- not counting core OAEP algorithm (6 points)
 * [ +1 ] converted back to correct big integer
 * [ +1 ] modpow
 * [ +3 ] correctly converts back to padded input (i.e. the
          number of leading zeros is correct and any marker
          bytes are properly removed)
 * [ +1 ] code checks that zero bytes were recovered
          don't forget to count off in verify if this check
          results in an exception or asertion failure

.sign() (6 points)
 [Do not count off if encrypt doesn't work]
 * [ +6 ] creates useful signature that work for messages of any size
   [ +3 ] creates useful signature, but only works for messages <= ~maxPlaintextLength

.verify() (6 points)
 * [ +3 ] correctly handles good signatures
 * [ +3 ] rejects bad signatures [no credit if crashes]
          do not give these points even if decrypt is the
          root cause

Penalties:
 * [ -3 ] does not implement padding and OAEP in separate methods


RSAKeyPair.java (10 points max)
=====================================================================
Note: Testing of e and d assume that e was used for the public key,
and d was used for the private key. If instead they use d for the public 
key, and e for the private key, this test may fail. However, students
should not lose points in this case.

 * [ -1 ] Outputs are insufficiently likely to be prime (certainty less 
          than 40 if they are using the certainty based constructor)

 * [ -3 ] modulus is incorrect (should be product of primes)

 * [ -2 ] e incorrectly calculated (or arbitrary e is picked
          and not checked!)

 * [ -2 ] d incorrectly calculated

 * [ -1 ] RSAKeys incorrectly generated from e, d, N
 
Performance problems
 * [ -5 ] Code functional but too slow because of fundamental flaw
   [ -2 ] Code functional but too slow because of careless error
   [ -1 ] Functional but too slow because e is fixed to 3. We told
          them this is possible so can't take off too much.


KeyExchange.java (17 points max)
=====================================================================

 * [ P.o.P. ] Only works in one order (other than example below)

 * [ P.o.P. ] Server and client do not agree on digest value,
              bug is not covered by rubric below

 * [ P.o.P. ] processIn does not always generate same value for same
              message, and bug is not covered by rubric below

 * [ P.o.P. ] Student attempts to use RSAKey or RSAKeyPair to solve
              problem.

 * [ P.o.P. ] Student does not use DHConstants or uses them incorrectly

Order issues:
 * [ -4 ] Initializes the secret in prepareOutMessage, so only works in one order

 random number selection issues (pick worst applicable deduction):
    * [ -2 ] randomly selected a and b are less than 64 bits
    * [ -4 ] randomly selected a and b generated with randInt
    * [ -2 ] doesn't check if generated output 1 < (g^x mod p) < p-1

 .processInMessage() input range issues:
    * [ -3 ] processIn accepts 1 AND p-1
    * [ -2 ] processIn accepts 1 or p-1, but not both
    * [ -2 ] careless error that results in almost-always null output

 .prepareOutMesssge() output range issues:
    * [ P.o.P. ] Negative valued secret
    * [ -5 ] output is not g.modPow(x, p), where x is some
             value known only to this instance of KeyExchange

 .processInMessage() output issues:
    * [ -3 ] processIn output lenght not designed to match 
             OUTPUT_SIZE_BYTES 
             (e.g. they return the .toByteArray() of the output
             of a modPow operation)
    * [ -1 ] If output length is just barely incorrect


    * [ -5 ] Output is not the inMessage.modPow(y, p), where 
             y is some value known only this instance of KeyExchange


Known errors that will not be caught by the autograder:
 * RSAKeyPair - having certainty that is too low
 * RSAKey - not padding the input to OAEP
 * KeyExchange - not using DHConstants. Using some less secure function
                 than g.modPow(x, p)
